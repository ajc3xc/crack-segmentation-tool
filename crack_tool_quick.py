# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'app.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import cracktools as ct
from layout import Ui_MainWindow
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QPixmap, QImage
from PyQt5.QtCore import Qt
import skimage
import numpy as np
import cv2
import matplotlib.pyplot as plt
import json
import os
from skimage.segmentation import mark_boundaries
import os
from PyQt5.QtWidgets import QListWidgetItem

from PyQt5.QtWidgets import QMessageBox
def error():
    msg = QMessageBox()
    msg.setIcon(QMessageBox.Critical)
    msg.setText("Error")
    msg.setWindowTitle("Error")
    msg.exec_()
    
from PyQt5.QtWidgets import QDialog, QVBoxLayout, QPushButton
from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton, QWidget, QVBoxLayout, QFileDialog
from PyQt5.QtGui import QPainter, QPen, QColor, QCursor
from PyQt5.QtCore import Qt, QPoint, QPointF

class CrackAnnotator(QWidget):
    def __init__(self, image=None):
        super().__init__()
        # — store & prepare image —
        self.orig_image = image
        if image is not None:
            h, w, _ = image.shape
            # convert to QPixmap once
            qimg = QImage(image.data, w, h, image.strides[0], QImage.Format_RGB888)
            self.image_pixmap = QPixmap.fromImage(qimg)
            self.setMinimumSize(w, h)
            self.resize(w, h)
        else:
            self.image_pixmap = None


        # — annotation state —
        self.points = []           # List[(x,y)]
        self.connections = []      # List[(i_from, i_to)]
        self.point_radius = 7
        self.connection_mode = False
        self.connecting_index = None
        self.hover_index = None
        self.hover_line_index = None

        # — zoom & pan state —
        self.scale = 1.0
        self.offset = QPoint(0, 0)
        self._panning = False
        self._last_pan = QPoint()

        self.setMouseTracking(True)
        self.setMinimumSize(700, 500)

    def toggle_mode(self):
        self.connection_mode = not self.connection_mode
        self.connecting_index = None
        self.update()

    # — zoom with wheel —
    def wheelEvent(self, event):
        f = 1.2 if event.angleDelta().y() > 0 else 1/1.2
        # Zoom centered on cursor:
        old_pos = event.pos()
        img_before = QPointF((old_pos.x()-self.offset.x())/self.scale,
                             (old_pos.y()-self.offset.y())/self.scale)
        self.scale *= f
        img_after = QPointF(img_before.x()*self.scale + self.offset.x(),
                             img_before.y()*self.scale + self.offset.y())
        self.offset += (old_pos - img_after.toPoint())
        self.update()

    # — pan with middle-mouse —
    def mousePressEvent(self, event):
        if event.button() == Qt.MiddleButton:
            self._panning = True
            self._last_pan = event.pos()
        else:
            # map to image coords for annotation logic:
            p = self._to_image_coords(event.pos())
            self._handle_annotation_click(p)
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        if self._panning:
            delta = event.pos() - self._last_pan
            self.offset += delta
            self._last_pan = event.pos()
        else:
            p = self._to_image_coords(event.pos())
            self.hover_index    = self._find_point_at(p)
            if self.connection_mode and self.connecting_index is None and self.hover_index is None:
                self.hover_line_index = self._find_line_at(p)
            else:
                self.hover_line_index = None
        self.update()
        super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.MiddleButton:
            self._panning = False
        super().mouseReleaseEvent(event)

    def _to_image_coords(self, pos):
        """Convert widget coords → image coords."""
        x = (pos.x() - self.offset.x()) / self.scale
        y = (pos.y() - self.offset.y()) / self.scale
        return (x, y)

    def _handle_annotation_click(self, pos):
        """Copy of original mousePressEvent logic, but using pos=(x,y)."""
        point_i = self._find_point_at(pos)
        line_i  = self._find_line_at(pos)
        if not self.connection_mode:
            if point_i is None:
                self.points.append(pos)
            else:
                # remove that point & any connections to it
                self.connections = [(i1,i2)
                    for i1,i2 in self.connections
                    if i1!=point_i and i2!=point_i]
                self.points.pop(point_i)
                # shift down subsequent indices
                self.connections = [(
                    i1-(i1>point_i),
                    i2-(i2>point_i))
                    for i1,i2 in self.connections]
        else:
            if line_i is not None and self.connecting_index is None and point_i is None:
                self.connections.pop(line_i)
            elif point_i is not None:
                if self.connecting_index is None:
                    self.connecting_index = point_i
                elif self.connecting_index!=point_i:
                    c = (self.connecting_index, point_i)
                    if c not in self.connections:
                        self.connections.append(c)
                    self.connecting_index = None
                else:
                    self.connecting_index = None
            else:
                self.connecting_index = None

    def paintEvent(self, event):
        qp = QPainter(self)
        qp.setRenderHint(QPainter.Antialiasing)

        # 1) draw background image with pan/zoom
        if self.image_pixmap:
            qp.translate(self.offset)
            qp.scale(self.scale, self.scale)
            qp.drawPixmap(0, 0, self.image_pixmap)

        # 2) draw connections
        for idx, (i1,i2) in enumerate(self.connections):
            x1,y1 = self.points[i1]; x2,y2 = self.points[i2]
            p1 = QPoint(int(round(x1)), int(round(y1)))
            p2 = QPoint(int(round(x2)), int(round(y2)))
            if (self.connection_mode and self.connecting_index is None
                and idx==self.hover_line_index and self.hover_index is None):
                pen = QPen(QColor(100,220,140), 6)
            else:
                pen = QPen(QColor(80,80,220), 4)
            qp.setPen(pen)
            qp.drawLine(p1, p2)
            self._draw_arrowhead(qp, p1, p2)

        # 3) draw points
        for i,(x,y) in enumerate(self.points):
            center = QPoint(int(round(x)), int(round(y)))
            brush = (QColor(0,200,0) if i==self.hover_index
                     or (self.connection_mode and i==self.connecting_index)
                     else QColor(200,80,80))
            qp.setBrush(brush)
            qp.setPen(Qt.NoPen)
            qp.drawEllipse(center, self.point_radius, self.point_radius)

    # — originals from connect_full_test.py: :contentReference[oaicite:2]{index=2} :contentReference[oaicite:3]{index=3}
    def _draw_arrowhead(self, qp, p1, p2):
        import math
        angle = math.atan2(p2.y()-p1.y(), p2.x()-p1.x())
        sz = 10
        dx1, dy1 = sz*math.cos(angle-math.pi/8), sz*math.sin(angle-math.pi/8)
        dx2, dy2 = sz*math.cos(angle+math.pi/8), sz*math.sin(angle+math.pi/8)
        left  = QPoint(int(p2.x()-dx1), int(p2.y()-dy1))
        right = QPoint(int(p2.x()-dx2), int(p2.y()-dy2))
        qp.setPen(Qt.NoPen); qp.setBrush(QColor(80,80,220))
        qp.drawPolygon(p2, left, right)

    def _find_point_at(self, pos):
        for i,(x,y) in enumerate(self.points):
            if (x-pos[0])**2 + (y-pos[1])**2 <= self.point_radius**2:
                return i
        return None

    def _find_line_at(self, pos):
        thr = 7
        for idx,(i1,i2) in enumerate(self.connections):
            x1,y1 = self.points[i1]; x2,y2 = self.points[i2]
            if self._dist_point_to_segment(pos,(x1,y1),(x2,y2)) < thr:
                return idx
        return None

    def _dist_point_to_segment(self, p, a, b):
        import numpy as np
        p,a,b = np.array(p), np.array(a), np.array(b)
        if np.all(a==b):
            return np.linalg.norm(p-a)
        t = max(0, min(1, np.dot(p-a, b-a)/np.dot(b-a, b-a)))
        proj = a + t*(b-a)
        return np.linalg.norm(p-proj)
    
class CrackToolsApplication(Ui_MainWindow):
    '''def setupUi(self,MainWindow):
        super().setupUi(MainWindow)
        self.MainWindow = MainWindow
        self.SelectFolderButton.clicked.connect(self.select_folder)
        self.PreviousImageButton.clicked.connect(self.previous_image)
        self.NextImageButton.clicked.connect(self.next_image)
        self.draw_box_button.clicked.connect(self.draw_box)
        self.save_b_button.clicked.connect(self.save_box)
        self.clear_boxes_button.clicked.connect(self.clear_boxes)  
        self.clear_segmentation_button.clicked.connect(self.clear_segmentation) 
        self.files_list.itemSelectionChanged.connect(self.name_selected)

        self.select_points_button.clicked.connect(self.select_end_points)
        self.update_image_crop_button.clicked.connect(self.update_image_crop)
        self.wavelet_button.clicked.connect(self.check_wavelet)
        self.middle_point_button.clicked.connect(self.select_middle_point)
        self.middpoint_update_button.clicked.connect(self.update_midpoint_image)
        self.update_os_button.clicked.connect(self.update_os)
        self.show_os_button.clicked.connect(self.show_os)
        self.update_cost_button.clicked.connect(self.update_cost)
        self.midline_track_button.clicked.connect(self.midline_tracking)
        self.update_track_display_button.clicked.connect(self.update_track_display)
        self.track_full_screen_button.clicked.connect(self.track_full_screen)
        self.edge_mask_button.clicked.connect(self.edge_mask)
        self.edge_tracks_button.clicked.connect(self.edge_tracking)
        self.edge_tracks_full_screen_button.clicked.connect(self.edge_tracks_full_screen)
        self.save_current_segment_button.clicked.connect(self.save_current_segment)
        self.draw_segment_button.clicked.connect(self.draw_segment)
        self.save_manuall_segment_button.clicked.connect(self.save_manual_segment)
        self.manual_segment_full_screen_button.clicked.connect(self.manual_segment_full_screen)

        # self.save_manuall_segment_button.clicked.connect(self.save_manual_segment)
        # self.manual_segment_full_screen_button.clicked.connect(self.manual_segment_full_screen)
        self.n = -1
        self.saved = False


        # self.select_points_button.setStyleSheet("background-color : red")
        self.update_image_crop_button.setStyleSheet("background-color : red")
        self.middle_point_button.setStyleSheet("background-color : red")
        self.middpoint_update_button.setStyleSheet("background-color : red")
        self.update_os_button.setStyleSheet("background-color : red")
        self.update_cost_button.setStyleSheet("background-color : red")
        self.midline_track_button.setStyleSheet("background-color : red")
        self.update_track_display_button.setStyleSheet("background-color : red")
        self.track_full_screen_button.setStyleSheet("background-color : red")
        self.edge_mask_button.setStyleSheet("background-color : red")
        self.edge_tracks_button.setStyleSheet("background-color : red")
        self.edge_tracks_full_screen_button.setStyleSheet("background-color : red")
        self.save_current_segment_button.setStyleSheet("background-color : red")
        self.draw_segment_button.setStyleSheet("background-color : red")
        self.show_os_button.setStyleSheet("background-color : red")'''
    
    def setupUi(self, MainWindow):
        super().setupUi(MainWindow)
        self.MainWindow = MainWindow
        self.SelectFolderButton.clicked.connect(self.select_folder)
        self.PreviousImageButton.clicked.connect(self.previous_image)
        self.NextImageButton.clicked.connect(self.next_image)
        self.draw_box_button.clicked.connect(self.draw_box)
        self.save_b_button.clicked.connect(self.save_box)
        self.clear_boxes_button.clicked.connect(self.clear_boxes)
        self.clear_segmentation_button.clicked.connect(self.clear_segmentation)
        self.files_list.itemSelectionChanged.connect(self.name_selected)

        self.select_points_button.clicked.connect(self.select_end_points)
        self.update_image_crop_button.clicked.connect(self.update_image_crop)
        self.wavelet_button.clicked.connect(self.check_wavelet)
        self.middle_point_button.clicked.connect(self.select_middle_point)
        self.middpoint_update_button.clicked.connect(self.update_midpoint_image)

        # Replace the following individual step connections
        # self.update_os_button.clicked.connect(self.update_os)
        # self.update_cost_button.clicked.connect(self.update_cost)
        # self.midline_track_button.clicked.connect(self.midline_tracking)
        # self.edge_mask_button.clicked.connect(self.edge_mask)
        # self.edge_tracks_button.clicked.connect(self.edge_tracking)
        # self.save_current_segment_button.clicked.connect(self.save_current_segment)

        # Hide step-by-step buttons not needed anymore
        self.show_os_button.hide()
        self.update_cost_button.hide()
        self.midline_track_button.hide()
        self.edge_mask_button.hide()
        self.edge_tracks_button.hide()
        self.save_current_segment_button.hide()

        # Repurpose the OS button for full pipeline
        try:
            self.update_os_button.clicked.disconnect()
        except Exception:
            pass
        self.update_os_button.setText("Run Full Pipeline")
        self.update_os_button.clicked.connect(self.run_pipeline)

        self.update_track_display_button.clicked.connect(self.update_track_display)
        self.track_full_screen_button.clicked.connect(self.track_full_screen)
        self.edge_tracks_full_screen_button.clicked.connect(self.edge_tracks_full_screen)
        self.draw_segment_button.clicked.connect(self.draw_segment)
        self.save_manuall_segment_button.clicked.connect(self.save_manual_segment)
        self.manual_segment_full_screen_button.clicked.connect(self.manual_segment_full_screen)

        self.n = -1
        self.saved = False

        self.update_image_crop_button.setStyleSheet("background-color : red")
        self.middle_point_button.setStyleSheet("background-color : red")
        self.middpoint_update_button.setStyleSheet("background-color : red")
        self.update_os_button.setStyleSheet("background-color : red")
        self.update_cost_button.setStyleSheet("background-color : red")
        self.midline_track_button.setStyleSheet("background-color : red")
        self.update_track_display_button.setStyleSheet("background-color : red")
        self.track_full_screen_button.setStyleSheet("background-color : red")
        self.edge_mask_button.setStyleSheet("background-color : red")
        self.edge_tracks_button.setStyleSheet("background-color : red")
        self.edge_tracks_full_screen_button.setStyleSheet("background-color : red")
        self.save_current_segment_button.setStyleSheet("background-color : red")
        self.draw_segment_button.setStyleSheet("background-color : red")
        self.show_os_button.setStyleSheet("background-color : red")

        # self.draw_segment_button.setStyleSheet("background-color : red")
####################### Select Image Tab ########################################
    def select_folder(self):
        try:
            dir = self.folder_line_edit.text().replace(" \ ", "/" )
            self.image_names = ct.tools.get_files(folder = dir,formats = ['jpg','png'],basename = False)
            for filename in self.image_names:
                self.files_list.addItem(os.path.basename(filename))
            self.n = 0
            self.change_image()
        except:
            error()

    def name_selected(self):
        self.n = self.files_list.currentRow()
        self.mid_pt = []
        self.end_points = []
        self.mask = []
        self.crack_tracks = {}
        self.cracks_stored_endpoints = {}
        self.crack_tracks = {}
        self.change_image()

    def update_selected_item(self,name):
        items = self.files_list.findItems(name, QtCore.Qt.MatchExactly)
        self.files_list.setCurrentItem(items[0])

    def change_image(self):
            w = self.segment_width_box_2.value()
            if self.track_color_box.currentText() == "R":
                color = (1,0,0)
            elif self.track_color_box.currentText() == "G":
                color = (0,1,0)
            elif self.track_color_box.currentText() == "B":
                color = (0,0,1)
            elif self.track_color_box.currentText() == "W":
                color = (1,1,1)
            self.update_selected_item(os.path.basename(self.image_names[self.n]))
            self.name = self.image_names[self.n]
            self.image = cv2.imread(self.name)[:,:,::-1].astype(np.uint8)
            self.original_image = self.image.copy()
            self.filename_label_2.setText(os.path.basename(self.name))

            im = self.original_image.astype(np.uint8)
            qimage = QImage(im, im.shape[1], im.shape[0], 
                            im.strides[0], QImage.Format_RGB888)
            pixmap = QPixmap.fromImage(qimage)
            scaled_pixmap = pixmap.scaled(self.ImageScreen.width(), self.ImageScreen.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
            self.ImageScreen.setPixmap(scaled_pixmap)

            self.ann_name = os.path.splitext(os.path.splitext(self.name)[0])[0] + '.json'
            if os.path.exists(self.ann_name):
                with open(self.ann_name) as f:
                    self.annotation = json.load(f)
                if 'annotations' in self.annotation.keys():
                    if 'crack_pixels' in self.annotation['annotations'].keys():
                        crack_pixels = self.annotation['annotations']['crack_pixels']
                        if crack_pixels != []:
                            mask = np.zeros((self.image.shape[0],self.image.shape[1]))
                            c = np.array(crack_pixels)
                            mask[list(c[:,0]),list(c[:,1])] = 1
                            # p = np.argwhere(mask==1)
                            self.image = (mark_boundaries(self.image/255, mask,
                                                                color=color, mode='inner', background_label=1)*255).astype(np.uint8)
                            
                            im = self.image.copy()
                            im = im.astype(np.uint8)
                            qimage = QImage(im, im.shape[1], im.shape[0], 
                                im.strides[0], QImage.Format_RGB888)
                            pixmap = QPixmap.fromImage(qimage)
                            scaled_pixmap = pixmap.scaled(self.ImageScreen.width(), self.ImageScreen.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
                            self.ImageScreen.setPixmap(scaled_pixmap)
                    if 'box' in self.annotation['annotations'].keys():
                        for key in self.annotation['annotations']['box'].keys():
                            if self.annotation['annotations']['box'][key]['class'] == 0:
                                color = (0,0,255)
                            elif self.annotation['annotations']['box'][key]['class'] == 1:
                                color = (0,255,0)
                            else:
                                color = (255,0,0)
                            bb_pts = np.array(self.annotation['annotations']['box'][key]['bounding_box'])
                            cv2.line(self.image,(bb_pts[0,0],bb_pts[0,1]),(bb_pts[1,0],bb_pts[0,1]),color,5)
                            cv2.line(self.image,(bb_pts[0,0],bb_pts[0,1]),(bb_pts[0,0],bb_pts[1,1]),color,5)
                            cv2.line(self.image,(bb_pts[1,0],bb_pts[1,1]),(bb_pts[0,0],bb_pts[1,1]),color,5)
                            cv2.line(self.image,(bb_pts[1,0],bb_pts[1,1]),(bb_pts[1,0],bb_pts[0,1]),color,5)
                            im = self.image.astype(np.uint8)
                            qimage = QImage(im, im.shape[1], im.shape[0], 
                                im.strides[0], QImage.Format_RGB888)
                            pixmap = QPixmap.fromImage(qimage)
                            scaled_pixmap = pixmap.scaled(self.ImageScreen.width(), self.ImageScreen.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
                            self.ImageScreen.setPixmap(scaled_pixmap)
                    else:
                        self.annotation['annotations']['box'] = {}
            else:
                self.annotation = {}
                self.annotation['image_name'] = self.name
                self.annotation['annotations'] = {}
                self.annotation["annotations"]["cracks end-points"] = []
                self.annotation["annotations"]["crack_pixels"] = []
                self.annotation["annotations"]['tracks'] = []
                self.annotation["annotations"]['box'] = {}  


    def next_image(self):
        try:
            self.mid_pt = []
            self.end_points = []
            self.mask = []
            self.crack_tracks = {}
            self.cracks_stored_endpoints = {}
            self.crack_tracks = {}
            self.n = self.n + 1
            self.change_image()
        except:
            error()

    def previous_image(self):
        try:
            self.mid_pt = []
            self.end_points = []
            self.mask = []
            self.crack_tracks = {}
            self.cracks_stored_endpoints = {}
            self.crack_tracks = {}
            self.n = self.n - 1
            self.change_image()
        except:
            error()
        
    def draw_box(self):
        self.image_size = self.select_image_size_2.value()
        self.bb_pts,_ = ct.tools.Draw().bounding_box(self.image[:,:,::-1],self.image_size)
        self.bb_pts = np.array(self.bb_pts,dtype = np.int32)
        self.saved = False
        if len(np.array(self.bb_pts))==2:
            cv2.line(self.image,(self.bb_pts[0,0],self.bb_pts[0,1]),(self.bb_pts[1,0],self.bb_pts[0,1]),(0,255,0),5)
            cv2.line(self.image,(self.bb_pts[0,0],self.bb_pts[0,1]),(self.bb_pts[0,0],self.bb_pts[1,1]),(0,255,0),5)
            cv2.line(self.image,(self.bb_pts[1,0],self.bb_pts[1,1]),(self.bb_pts[0,0],self.bb_pts[1,1]),(0,255,0),5)
            cv2.line(self.image,(self.bb_pts[1,0],self.bb_pts[1,1]),(self.bb_pts[1,0],self.bb_pts[0,1]),(0,255,0),5)

            # self.image[self.bb_pts[0,0],self.bb_pts[1,0],:] = [0,255,0]
            # self.image[self.bb_pts[1,1],self.bb_pts[0,1],:] = [0,255,0]
            # self.image[self.bb_pts[1,1],self.bb_pts[1,0],:] = [0,255,0]
            im = self.image.astype(np.uint8)
            qimage = QImage(im, im.shape[1], im.shape[0], 
                im.strides[0], QImage.Format_RGB888)
            pixmap = QPixmap.fromImage(qimage)
            scaled_pixmap = pixmap.scaled(self.ImageScreen.width(), self.ImageScreen.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
            self.ImageScreen.setPixmap(scaled_pixmap)

    def save_box(self):
        class_ = self.ClassSpinBox.value()
        if self.saved == False:
            self.saved = True
            if len(self.bb_pts)>0:
                if len(np.fromiter(self.annotation['annotations']['box'].keys(),float))==0:
                    self.annotation['annotations']['box'][1] = {'bounding_box':self.bb_pts.tolist(),'class':class_}
                    json_file = json.dumps(self.annotation)
                    with open(self.ann_name, 'w') as f:        
                        f.write(json_file)   
                        print('saved')
                else:
                    self.annotation['annotations']['box'][int(np.max(np.fromiter(self.annotation['annotations']['box'].keys(),float))+1)] = {'bounding_box':self.bb_pts.tolist(),'class':class_}
                    with open(self.ann_name, 'w') as fp:
                        json.dump(self.annotation, fp)
                    print('saved')
            else:
                print('no box to save')
        
        self.change_image()

    def clear_boxes(self):
        self.annotation['annotations']['box'] = {}
        with open(self.ann_name, 'w') as fp:
            json.dump(self.annotation, fp)
        print('saved')
        self.change_image()

    def clear_segmentation(self):
        self.annotation["annotations"]["cracks end-points"] = []
        self.annotation["annotations"]["crack_pixels"] = []
        self.annotation["annotations"]['tracks'] = []
        with open(self.ann_name, 'w') as fp:
            json.dump(self.annotation, fp)
        print('saved')
        self.change_image()

    def annotation_full_screen(self):
        try:
            self.image_size = self.select_image_size.value()
            _,_ = ct.tools.Draw().bounding_box(self.image[:,:,::-1],self.image_size)
        except:
            error()
################################################################################################################

    def select_end_points(self):
        try :
            self.image_size = self.select_image_size.value()
            ptss = ct.tools.Draw().points(self.image[:,:,::-1],self.image_size,move_x = 0,move_y = 0)
            self.end_points = ptss
            self.points_pairs_list = [ptss[b*2:b*2+2] for b in range(len(ptss))]
            if len(self.points_pairs_list) == 2:
                self.update_image_crop_button.setStyleSheet("background-color : lightblue")
                self.middle_point_button.setStyleSheet("background-color : lightblue")
            else:
                self.update_image_crop_button.setStyleSheet("background-color : red")
                self.middle_point_button.setStyleSheet("background-color : red")
        except :
            error()
            self.update_image_crop_button.setStyleSheet("background-color : red")
            self.middle_point_button.setStyleSheet("background-color : red")

    def select_end_points(self):
        if not hasattr(self, "original_image") or self.original_image is None:
            error()
            return

        #from connect_full_test import CrackAnnotator
        from PyQt5.QtWidgets import QDialog, QVBoxLayout, QHBoxLayout, QPushButton, QSizePolicy, QApplication

        dlg = QDialog(self.MainWindow)
        dlg.setWindowTitle("Mark Endpoints & Connections")
        dlg.setWindowModality(Qt.ApplicationModal)
        dlg.setWindowFlags(dlg.windowFlags() | Qt.WindowMaximizeButtonHint)
        layout = QVBoxLayout(dlg)

        # Mode toggle button
        mode_btn = QPushButton("Switch to Connection Mode")
        mode_btn.setCheckable(True)
        layout.addWidget(mode_btn)

        from PyQt5.QtWidgets import QScrollArea

        annot = CrackAnnotator(image=self.original_image)
        annot.setSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Ignored)

        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setWidget(annot)
        layout.addWidget(scroll, 1)  # stretch=1


        # Mode button updates
        def update_mode_text():
            if annot.connection_mode:
                mode_btn.setText("Switch to Point Mode")
                mode_btn.setStyleSheet("background: #97e297;")
            else:
                mode_btn.setText("Switch to Connection Mode")
                mode_btn.setStyleSheet("background: #e2c297;")
        mode_btn.clicked.connect(lambda: (annot.toggle_mode(), update_mode_text()))
        update_mode_text()  # Set the initial text

        # OK and Cancel buttons
        btn_layout = QHBoxLayout()
        btn_done   = QPushButton("Done")
        btn_cancel = QPushButton("Cancel")
        btn_done.clicked.connect(dlg.accept)
        btn_cancel.clicked.connect(dlg.reject)
        btn_layout.addWidget(btn_done)
        btn_layout.addWidget(btn_cancel)
        layout.addLayout(btn_layout)

        # Maximize dialog to full screen (after it is set up)
        dlg.showMaximized()
        QApplication.processEvents()  # Ensure layout is updated

        # Run the dialog
        if dlg.exec_() != QDialog.Accepted:
            return

        pts = annot.points
        conns = annot.connections
        self.endpoint_pairs = [[pts[a], pts[b]] for a, b in conns]

        color = "lightblue" if self.endpoint_pairs else "red"
        self.update_image_crop_button.setStyleSheet(f"background-color: {color}")

    def update_image_crop(self):
        try :
            y_margin = self.y_margin_box.value()
            x_margin = self.x_margin_box.value()
            downsample_factor = self.downsample_factor_box.value()
            color_channel = [0 if self.color_chenel_box.currentText()=='R' else 1 if self.color_chenel_box.currentText()=='B' else 2]
            if self.end_points == []:
                self.select_end_points()
            self.pts = self.end_points
            black_crack = [0 if self.crack_color_box.currentText() =='Bright crack' else 1 ][0]
            if black_crack==1:
                func = np.min
            elif  black_crack==0:
                func = np.max
            self.image_crop,self.pts_crop = ct.tools.image_crop(self.original_image,self.pts[0],self.pts[1],self.pts,y_margin,x_margin)
            self.image_crop_down = skimage.measure.block_reduce(self.image_crop, block_size=(downsample_factor, downsample_factor, 1),
                                                    func=func, cval=0, func_kwargs=None)
            self.pts_crop_down = [x / downsample_factor for x in self.pts_crop]
            self.image_down = skimage.measure.block_reduce(self.original_image, block_size=(downsample_factor, downsample_factor, 1),
                                                    func=func, cval=0, func_kwargs=None)
            self.pts_down = [x / downsample_factor for x in self.pts]
            gs_image = self.image_crop_down[:,:,color_channel].astype(np.uint8)
            gs_image = cv2.circle(gs_image,center = (int(self.pts_crop_down[0][0]),int(self.pts_crop_down[0][1])),
                                radius = 2,color = (0,255,0),thickness = 2)
            gs_image = cv2.circle(gs_image,center = (int(self.pts_crop_down[1][0]),int(self.pts_crop_down[1][1])),
                                radius = 2,color = (0,255,0),thickness = 2)
            qimage = QImage(gs_image.astype(dtype=np.uint8), gs_image.shape[1], gs_image.shape[0], 
                            gs_image.strides[0], QImage.Format_Grayscale8)
            pixmap = QPixmap.fromImage(qimage)
            scaled_pixmap = pixmap.scaled(self.image_crop_down_display.width(), self.image_crop_down_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
            self.image_crop_down_display.setPixmap(scaled_pixmap)
            self.x_size_show.display(self.image_crop_down.shape[1])
            self.y_size_show.display(self.image_crop_down.shape[0])
            self.update_os_button.setStyleSheet("background-color : lightblue")
        except :
            error()
            self.update_os_button.setStyleSheet("background-color : red")

    def check_wavelet(self):
        try:
            size = self.wavelet_size_box.value()
            nOrientations = self.wavelet_norientations_box.value()
            design = "N"
            inflectionPoint = self.wavelet_inflection_point_box.value()
            mnOrder = self.wavelet_mnorder_box.value()
            splineOrder = 3
            overlapFactor = self.wavelet_overlap_factor_box.value()
            dcStdDev = self.wavelet_STD_box.value()
            directional = False
            window_size = self.wavelet_window_size_box.value()

            wavelet = ct.os.CheckWavelet(window_size = window_size, size = size, nOrientations = nOrientations, design = design, 
                            inflectionPoint = inflectionPoint, mnOrder = mnOrder, splineOrder = splineOrder,
                            overlapFactor = overlapFactor, dcStdDev = dcStdDev, directional = directional,
                            display_orientations=[0])[0,:,:]
            wavelet = wavelet - np.min(wavelet)
            wavelet = (wavelet*254/np.max(wavelet)).astype(dtype=np.int8)

            qimage = QImage(wavelet.astype(dtype=np.uint8), wavelet.shape[1], wavelet.shape[0], 
                            wavelet.strides[0], QImage.Format_Grayscale8)
            pixmap = QPixmap.fromImage(qimage)
            scaled_pixmap = pixmap.scaled(self.wavelet_check_display.width(), self.wavelet_check_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
            self.wavelet_check_display.setPixmap(scaled_pixmap)
        except:
            error()

    def select_middle_point(self):
        try :
            self.image_size = self.select_image_size.value()
            downsample_factor = self.downsample_factor_box.value()
            mid_pt = ct.tools.Draw().points(self.image[:,:,::-1],self.image_size,move_x = 0,move_y = 0)
            self.mid_pt = (int(mid_pt[0][0]/downsample_factor),int(mid_pt[0][1]/downsample_factor))
            self.middpoint_update_button.setStyleSheet("background-color : lightblue")
        except :
            error()
            self.middpoint_update_button.setStyleSheet("background-color : red")

    def update_midpoint_image(self):
        try:
            self.image_size = self.select_image_size.value()
            downsample_factor = self.downsample_factor_box.value()
            color_channel = [0 if self.color_chenel_box.currentText()=='R' else 1 if self.color_chenel_box.currentText()=='B' else 2]
            d = int(self.wavelet_window_size_box.value()/2)
            if self.mid_pt == []:
                self.select_middle_point()
            try :
                mid_image = self.image_down[int(self.mid_pt[1])-d:int(self.mid_pt[1])+d,
                                int(self.mid_pt[0])-d:int(self.mid_pt[0])+d]
            except:
                black_crack = [-1 if self.crack_color_box.currentText() =='Bright crack' else 1 ][0]
                if black_crack==1:
                    func = np.min
                elif  black_crack==-1:
                    func = np.max
                self.image_down = skimage.measure.block_reduce(self.original_image, block_size=(downsample_factor, downsample_factor, 1),
                                                    func=func, cval=0, func_kwargs=None)
                mid_image = self.image_down[int(self.mid_pt[1])-d:int(self.mid_pt[1])+d,
                                int(self.mid_pt[0])-d:int(self.mid_pt[0])+d]
            mid_image = mid_image[:,:,color_channel]
            qimage = QImage(mid_image.astype(dtype=np.uint8), mid_image.shape[1], mid_image.shape[0], 
                            mid_image.strides[0], QImage.Format_Grayscale8)
            pixmap = QPixmap.fromImage(qimage)
            scaled_pixmap = pixmap.scaled(self.middlepoint_display.width(), self.middlepoint_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
            self.middlepoint_display.setPixmap(scaled_pixmap)
        except :
            error()

    def update_os(self):
        try:
            self.os_progress_bar.setValue(0)
            color_channel = [0 if self.color_chenel_box.currentText()=='R' else 1 if self.color_chenel_box.currentText()=='B' else 2][0]
            black_crack = [-1 if self.crack_color_box.currentText() =='Bright crack' else 1 ][0]
            size = self.wavelet_size_box.value()
            nOrientations = self.wavelet_norientations_box.value()
            design = "N"
            inflectionPoint = self.wavelet_inflection_point_box.value()
            mnOrder = self.wavelet_mnorder_box.value()
            splineOrder = 3
            overlapFactor = self.wavelet_overlap_factor_box.value()
            dcStdDev = self.wavelet_STD_box.value()
            directional = False
            self.osGFCost = ct.os.OrientationScoreTransform(self.image_crop_down[:,:,color_channel]/255*black_crack, size = size, 
                                            nOrientations = nOrientations, design = design, 
                                            inflectionPoint = inflectionPoint, mnOrder = mnOrder, 
                                            splineOrder = splineOrder, overlapFactor = overlapFactor, 
                                            dcStdDev = dcStdDev, directional = directional)
            self.os_progress_bar.setValue(100)
            self.update_cost_button.setStyleSheet("background-color : lightblue")
            self.show_os_button.setStyleSheet("background-color : lightblue")
        except:
            error()
            self.update_cost_button.setStyleSheet("background-color : red")
            self.show_os_button.setStyleSheet("background-color : red")

    def show_os(self):
        import plotly.graph_objects as go
        import numpy as np
        color_channel = [0 if self.color_chenel_box.currentText()=='R' else 1 if self.color_chenel_box.currentText()=='B' else 2]
        shift = -30
        osGFCost_shift = np.roll(self.osGFCost, shift=shift,axis = 0)
        osGFCost_shift.shape
        downsample_factor = self.downsample_factor_box.value()
        downsample_rate_spatial = downsample_factor
        downsample_rate_angular = 1
        # angular_shift = int(1*osGFCost.shape[0])
        # osGFCosts = 
        values = osGFCost_shift[:int(self.osGFCost.shape[0]/2),:,:].real
        X, Y, Z = np.mgrid[:values.shape[0],:values.shape[1],:values.shape[2]]
   
        # image_gray_cropp_down = scipy.ndimage.zoom(self.image_crop[:,:,color_channel], 
        #                                         ((Y.shape[1])/self.image_crop.shape[0],
        #                                                             (Y.shape[2])/self.image_crop.shape[1]), order=3)
        yim = np.linspace(0,self.image_crop_down.shape[0],self.image_crop_down.shape[0])
        zim = np.linspace(0,self.image_crop_down.shape[1],self.image_crop_down.shape[1])


        yim,zim = np.meshgrid(yim,zim)
        xim = np.ones(yim.shape)*0

        a = self.osGFCost.shape[0]/2-1
        b = self.osGFCost.shape[1]
        c = self.osGFCost.shape[2]

        fig = go.Figure(data=go.Volume(
            x=X.flatten(),
            y=Y.flatten(),
            z=Z.flatten(),
            value=values.flatten(),
            isomin=np.min(values),
            isomax=np.max(values),
            opacity=1, # needs to be small to see through all surfaces
            opacityscale='min',
            colorscale='Hot',
            caps= dict(x_show=False, y_show=False, z_show=False, x_fill=1),

        ))

        fig.update_traces(lighting=dict(ambient = 0.4,diffuse = 0.9,fresnel = 0.8,roughness = 0.5,specular = 0.05),
                        selector=dict(type='volume'))


        fig.update_traces(surface=dict(count=5,fill = 1,pattern='all',show=True), selector=dict(type='volume'))


        r = self.image_crop.shape[0]/self.image_crop_down.shape[1]
        fig.update_layout(scene_aspectmode='manual',
                        scene_aspectratio=dict(x=0.5, y=r, z=1))

        fig.update_layout(scene_xaxis_showticklabels=False,
                        scene_yaxis_showticklabels=False,
                        scene_zaxis_showticklabels=False),
        fig.add_surface(x=xim, y=yim, z=zim, 
                        surfacecolor=self.image_crop_down[:,:,color_channel][:,:,0].T, 
                        colorscale='gray', 
                        showscale=False)

        fig.add_scatter3d(
                x=[0, 0, a, a, 0, 0, a, a, a, 0, 0, 0, 0, a, a, a],
                y=[0, b, b, 0, 0, 0, 0, b, b, b, b, 0, b, b, 0, 0],
                z=[0, 0, 0, 0, 0, c, c, c, 0, 0, c, c, c, c, c, 0],
            mode = 'lines',
            line=dict(
                color='black',
                width=2
            )
        )

        fig.update_layout(scene = dict(
                            xaxis = dict(showbackground=False),
                            yaxis = dict(showbackground=False),
                            zaxis = dict(showbackground=False)))
        fig.update_layout(scene = dict(
                            xaxis_title="θ",
                            yaxis_title='x1',
                            zaxis_title='x2'))



        fig.update_traces(showscale=True, selector=dict(type='volume'))
        fig.update_layout(margin_autoexpand=True)
        fig.update_layout(font=dict(size = 60))
        k = 4.5
        camera = dict(
            up=dict(x=1, y=0, z=0),
            center=dict(x=-0.15, y=0, z=0),
            eye=dict(x=0.085*k, y=0.23*k, z=0.2*k)
        )
        fig.update_layout(scene_camera=camera,title='default')

        fig.show()

    def update_cost(self):
        try:
            self.update_cost_bar.setValue(0)
            lambdaa = self.lambda_box.value()
            p = self.power_box.value()
            ksi = 1
            zeta = 1
            sigmas = self.sigmas_line_edit.text()
            sigmas = [float(i) for i in sigmas.split(sep = ',')]
            sigmas_ext = 1
            self.multiscalecostLIFExtReg = ct.os.MultiScaleVesselness(self.osGFCost.real,ksi,1,sigmas,"LIF",sigmas_ext = sigmas_ext)

            costmultiscale = ct.os.MultiScaleVesselnessFilter(self.multiscalecostLIFExtReg)
            self.costFunction = ct.os.CostFunction(costmultiscale,lambdaa = lambdaa, p = p)
            c00 = np.min(ct.os.Rescale(self.costFunction),axis = 0)
            self.update_cost_bar.setValue(100)
            c00 = c00 - np.min(c00)
            c00 = (c00*255/np.max(c00)).astype(dtype=np.uint8)
            qimage = QImage(c00.astype(dtype=np.uint8), c00.shape[1], c00.shape[0], 
                            c00.strides[0], QImage.Format_Grayscale8)
            pixmap = QPixmap.fromImage(qimage)
            scaled_pixmap = pixmap.scaled(self.cost_display.width(), self.cost_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
            self.cost_display.setPixmap(scaled_pixmap)
            self.midline_track_button.setStyleSheet("background-color : lightblue")
        except:
            error()
            self.midline_track_button.setStyleSheet("background-color : red")

    def midline_tracking(self):
        try :
            self.tracking_bar.setValue(0)
            w = self.track_width_box.value()
            if self.track_color_box.currentText() == "R":
                color = (255,0,0)
            elif self.track_color_box.currentText() == "G":
                color = (0,255,0)
            elif self.track_color_box.currentText() == "B":
                color = (0,0,255)
            elif self.track_color_box.currentText() == "W":
                color = (255,255,255)

            y_margin = self.y_margin_box.value()
            x_margin = self.x_margin_box.value()
            g11 = self.g11_box.value()
            g22 = self.g22_box.value()
            g33 = self.g33_box.value()
            x_margin = self.x_margin_box.value()
            downsample_factor = self.downsample_factor_box.value()


            track_crop_down = ct.tracking.fast_marching(self.costFunction,self.pts_crop_down[0],self.pts_crop_down[1],g11=g11,g22=g22,g33=g33)
            track_crop_down[0] = track_crop_down[0]-0.5
            track_crop_down[1] = track_crop_down[1]-0.5
            track_crop = track_crop_down.copy()
            track_crop[0] = track_crop_down[0]*downsample_factor
            track_crop[1] = track_crop_down[1]*downsample_factor
            self.track_crop = track_crop
            track = ct.tools.track_crop_to_full(track_crop,self.pts[0],self.pts[1],y_margin,x_margin)
            self.track = track
            pts = np.array(track_crop).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
            im = self.image_crop.astype(np.uint8)
            im = cv2.polylines(im, [pts], False, color, w)

            qimage = QImage(im, im.shape[1], im.shape[0], 
                            im.strides[0], QImage.Format_RGB888)
            pixmap = QPixmap.fromImage(qimage)
            scaled_pixmap = pixmap.scaled(self.track_display.width(), self.track_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
            self.track_display.setPixmap(scaled_pixmap)
            self.tracking_bar.setValue(100)
            self.update_track_display_button.setStyleSheet("background-color : lightblue")
            self.track_full_screen_button.setStyleSheet("background-color : lightblue")
            self.edge_mask_button.setStyleSheet("background-color : lightblue")
        except :
            error()
            self.update_track_display_button.setStyleSheet("background-color : red")
            self.track_full_screen_button.setStyleSheet("background-color : red")
            self.edge_mask_button.setStyleSheet("background-color : red")

    
    def update_track_display(self):
        try :
            w = self.track_width_box.value()
            if self.track_color_box.currentText() == "R":
                color = (255,0,0)
            elif self.track_color_box.currentText() == "G":
                color = (0,255,0)
            elif self.track_color_box.currentText() == "B":
                color = (0,0,255)
            elif self.track_color_box.currentText() == "W":
                color = (255,255,255)
            pts = np.array(self.track_crop).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
            im = self.image_crop.astype(np.uint8)
            im = cv2.polylines(im, [pts], False, color, w)
            qimage = QImage(im, im.shape[1], im.shape[0], 
                            im.strides[0], QImage.Format_RGB888)
            pixmap = QPixmap.fromImage(qimage)
            scaled_pixmap = pixmap.scaled(self.track_display.width(), self.track_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
            self.track_display.setPixmap(scaled_pixmap)
        except:
            error()

    def track_full_screen(self):
        try :
            w = self.track_width_box.value()
            if self.track_color_box.currentText() == "R":
                color = (255,0,0)
                c = 'r'
            elif self.track_color_box.currentText() == "G":
                color = (0,255,0)
                c = 'g'
            elif self.track_color_box.currentText() == "B":
                color = (0,0,255)
                c = 'b'
            elif self.track_color_box.currentText() == "W":
                color = (255,255,255)
                c = 'w'

            im = self.image.astype(np.uint8)
            plt.imshow(im)
            plt.plot(self.track[0],self.track[1],color = c,linewidth=w)
            plt.show()
        except :
            error()

    def edge_mask(self):
        try:
            window_half_size = int(self.edge_filter_size_box.value()/2)

            y_margin = self.y_margin_box.value()
            x_margin = self.x_margin_box.value()


            black_crack = [-1 if self.crack_color_box.currentText() =='Bright crack' else 1 ][0]
            color_channel = [0 if self.color_chenel_box.currentText()=='R' else 1 if self.color_chenel_box.currentText()=='B' else 2][0]
            self.edge_mask1, self.edge_mask2 = ct.segmentation.edge_masks(self.original_image[:,:,color_channel]*black_crack,np.array(self.track),window_half_size=window_half_size)

            self.edge_mask1_crop,pts_crop = ct.tools.image_crop(self.edge_mask1[:,:,np.newaxis],self.pts[0],self.pts[1],self.pts,y_margin,x_margin)
            self.edge_mask2_crop,pts_crop = ct.tools.image_crop(self.edge_mask2[:,:,np.newaxis],self.pts[0],self.pts[1],self.pts,y_margin,x_margin)

            edge_mask1_crop = self.edge_mask1_crop - np.min(self.edge_mask1_crop)
            edge_mask1_crop = (edge_mask1_crop*255/np.max(edge_mask1_crop)).astype(dtype=np.uint8)

            qimage = QImage(edge_mask1_crop.astype(dtype=np.uint8), edge_mask1_crop.shape[1], edge_mask1_crop.shape[0], 
                            edge_mask1_crop.strides[0], QImage.Format_Grayscale8)
            pixmap = QPixmap.fromImage(qimage)
            scaled_pixmap = pixmap.scaled(self.edge_map_display.width(), self.edge_map_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
            self.edge_map_display.setPixmap(scaled_pixmap)
            self.edge_tracks_button.setStyleSheet("background-color : lightblue")
        except:
            error()
            self.edge_tracks_button.setStyleSheet("background-color : red")

    def edge_tracking(self):
        try :
            color_channel = [0 if self.color_chenel_box.currentText()=='R' else 1 if self.color_chenel_box.currentText()=='B' else 2][0]
            y_margin = self.y_margin_box.value()
            x_margin = self.x_margin_box.value()

            w = self.edge_track_width_box.value()
            if self.edge_track_color_box.currentText() == "R":
                color = (255,0,0)
            elif self.edge_track_color_box.currentText() == "G":
                color = (0,255,0)
            elif self.edge_track_color_box.currentText() == "B":
                color = (0,0,255)
            elif self.edge_track_color_box.currentText() == "W":
                color = (255,255,255)

            mu = self.mu_box.value()
            l = self.l_box.value()
            p = self.p_box.value()

            track_e1_crop, track_e2_crop = ct.segmentation.edges_tracking(self.image_crop[:,:,color_channel], self.pts_crop, 
                                                        self.edge_mask1_crop,self.edge_mask2_crop, mu = mu,l = l, p = p)
            track_e1_crop = track_e1_crop[::-1]
            track_e2_crop = track_e2_crop[::-1]

            track_e1_crop[0] = track_e1_crop[0] - 0.5
            track_e2_crop[0] = track_e2_crop[0] - 0.5

            track_e1_crop[1] = track_e1_crop[1] - 0.5
            track_e2_crop[1] = track_e2_crop[1] - 0.5

            self.track_e1 = ct.tools.track_crop_to_full(track_e1_crop,self.pts[0],self.pts[1],y_margin,x_margin)
            self.track_e2 = ct.tools.track_crop_to_full(track_e2_crop,self.pts[0],self.pts[1],y_margin,x_margin)


            pts1 = np.array(track_e1_crop).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
            pts2 = np.array(track_e2_crop).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
            im = self.image_crop.astype(np.uint8)
            im = cv2.polylines(im, [pts1], False, color, w)
            im = cv2.polylines(im, [pts2], False, color, w)
            qimage = QImage(im, im.shape[1], im.shape[0], 
                            im.strides[0], QImage.Format_RGB888)
            pixmap = QPixmap.fromImage(qimage)
            scaled_pixmap = pixmap.scaled(self.edge_tracks_display.width(), self.edge_tracks_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
            self.edge_tracks_display.setPixmap(scaled_pixmap)
            self.edge_tracks_full_screen_button.setStyleSheet("background-color : lightblue")
            self.edge_tracks_full_screen_button.setStyleSheet("background-color : lightblue")
            self.save_current_segment_button.setStyleSheet("background-color : lightblue")
        except :
            error()
            self.edge_tracks_full_screen_button.setStyleSheet("background-color : reed")
            self.edge_tracks_full_screen_button.setStyleSheet("background-color : red")
            self.save_current_segment_button.setStyleSheet("background-color : red")

    def edge_tracks_full_screen(self):
        try:
            w = self.edge_track_width_box.value()
            if self.edge_track_color_box.currentText() == "R":
                c = 'r'
            elif self.edge_track_color_box.currentText() == "G":
                c = 'g'
            elif self.edge_track_color_box.currentText() == "B":
                c = 'b'
            elif self.edge_track_color_box.currentText() == "W":
                c = 'w'

            im = self.image.astype(np.uint8)
            plt.imshow(im)
            plt.plot(self.track_e1[0],self.track_e1[1],color = c,linewidth=w)
            plt.plot(self.track_e2[0],self.track_e2[1],color = c,linewidth=w)
            plt.show()
        except:
            error()

    def save_current_segment(self):
        try:
            edge_x = np.concatenate((self.track_e1[1][::-1],self.track_e2[1]))
            edge_y = np.concatenate((self.track_e1[0][::-1],self.track_e2[0]))

            mask_FM = ct.segmentation.create_mask(self.image,edge_y,edge_x)
            self.mask.append(mask_FM)
            track = [list(x) for x in self.track]
            self.cracks_stored_endpoints[len(self.cracks_stored_endpoints.keys())] = [self.pts[0].tolist(),self.pts[1].tolist()]
            self.crack_tracks[len(self.crack_tracks)] = track
            m = np.sum(np.array(self.mask),axis = 0)
            m[m>=1] = 255
            m = m.astype(dtype=np.uint8)
            qimage = QImage(m.astype(dtype=np.uint8), m.shape[1], m.shape[0], 
                            m.strides[0], QImage.Format_Grayscale8)
            pixmap = QPixmap.fromImage(qimage)
            scaled_pixmap = pixmap.scaled(self.all_segments_display.width(), self.all_segments_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
            self.all_segments_display.setPixmap(scaled_pixmap)

            pts1 = np.array(self.track_e1).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
            pts2 = np.array(self.track_e2).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
            im = self.image.astype(np.uint8).copy()
            im = cv2.polylines(im, [pts1], False, (0,255,0), 1)
            im = cv2.polylines(im, [pts2], False, (0,255,0), 1)
            self.image = im

            self.save_annotation()

        except :
            error()

        # plt.imshow(m)
        # plt.plot(self.track_e1[0],self.track_e1[1],'r')
        # plt.plot(self.track_e2[0],self.track_e2[1],'r')
        # plt.show()

    def draw_segment(self):
        try:
            image_size = self.select_image_size.value()
            x,y = ct.tools.Draw().counturs(self.image[:,:,::-1],image_size)
            if len(x) == 0:
                return
            x = np.concatenate([x,np.array(x[0]).reshape(1)])
            y = np.concatenate([y,np.array(y[0]).reshape(1)])
            self.manuall_x = np.array(x)
            self.manuall_y = np.array(y)

            pts = np.array([x,y]).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
            im = self.image.astype(np.uint8)
            im = cv2.polylines(im, [pts], False, (0, 255, 0), 1)

            qimage = QImage(im, im.shape[1], im.shape[0], 
                            im.strides[0], QImage.Format_RGB888)
            pixmap = QPixmap.fromImage(qimage)
            scaled_pixmap = pixmap.scaled(self.manual_segment_screen.width(), self.manual_segment_screen.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
            self.manual_segment_screen.setPixmap(scaled_pixmap)
        except :
            error()


    def manual_segment_full_screen(self):
        try:
            pts = np.array([self.manuall_x,self.manuall_y]).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
            im = self.image.astype(np.uint8).copy()
            plt.imshow(im)
            plt.plot(self.manuall_x,self.manuall_y,'r',linewidth = 1)
            plt.show()
        except:
            error()

    def save_manual_segment(self):
        try:
            mask_FM = ct.segmentation.create_mask(self.image,self.manuall_x,self.manuall_y)
            self.mask.append(mask_FM)
            m = np.sum(np.array(self.mask),axis = 0)
            m[m>=1] = 255
            m = m.astype(dtype=np.uint8)
            pts = np.array([self.manuall_x,self.manuall_y]).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
            im = self.image.astype(np.uint8).copy()
            im = cv2.polylines(im, [pts], False, (0,255,0), 1)
            self.image = im

            self.save_annotation()
        except:
            error()

    def save_annotation(self):
        try:
            self.annotation["annotations"]["cracks end-points"] = self.cracks_stored_endpoints
            m = np.sum(np.array(self.mask),axis = 0)
            m[m>=1] = 1.0
            crack_pixels = np.argwhere(m==1.0)
            self.annotation["annotations"]["crack_pixels"] = crack_pixels.tolist()
            self.annotation["annotations"]['tracks'] = self.crack_tracks
            json_file = json.dumps(self.annotation)
            with open(os.path.splitext(os.path.splitext(self.name)[0])[0] + '.json', 'w') as f:        
                f.write(json_file)
            self.change_image()

            self.update_image_crop_button.setStyleSheet("background-color : red")
            self.middle_point_button.setStyleSheet("background-color : red")
            self.middpoint_update_button.setStyleSheet("background-color : red")
            self.update_os_button.setStyleSheet("background-color : red")
            self.update_cost_button.setStyleSheet("background-color : red")
            self.midline_track_button.setStyleSheet("background-color : red")
            self.update_track_display_button.setStyleSheet("background-color : red")
            self.track_full_screen_button.setStyleSheet("background-color : red")
            self.edge_mask_button.setStyleSheet("background-color : red")
            self.edge_tracks_button.setStyleSheet("background-color : red")
            self.edge_tracks_full_screen_button.setStyleSheet("background-color : red")
            self.save_current_segment_button.setStyleSheet("background-color : red")
        except:
            error()
            
    def run_pipeline(self):
        """
        Runs OS, cost map, crack track, segmentation in sequence,
        then saves and displays the result automatically.
        """
        try:
            self.update_image_crop()        # If needed
            self.update_os()
            self.update_cost()
            self.midline_tracking()
            self.edge_mask()
            self.edge_tracking()
            self.save_current_segment()
            print("Pipeline complete – segmentation saved and displayed.")
        except Exception as e:
            print(f"Pipeline failed: {e}")
            # Optional: show a popup or error message
            
    def run_pipeline(self):
        """
        For each endpoint‐pair in self.endpoint_pairs,
        run crop → OS → cost → midline → edges → save.
        """
        if not self.endpoint_pairs:
            error()
            return

        for pair in self.endpoint_pairs:
            self.pts = pair
            try:
                self.update_image_crop()
                self.update_os()
                self.update_cost()
                self.midline_tracking()
                self.edge_mask()
                self.edge_tracking()
                self.save_current_segment()
            except Exception as e:
                print(f"⚠ Pipeline failed for endpoints {pair}: {e}")

        print("✔ All endpoint‐groups processed.")


if __name__ == "__main__":
    import sys
    import time
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = CrackToolsApplication()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())