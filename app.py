# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'app.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import cracktools as ct
from layout import Ui_MainWindow
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QPixmap, QImage
from PyQt5.QtCore import Qt
import skimage
import numpy as np
import cv2
import matplotlib.pyplot as plt
import json
import os
    
class CrackToolsApplication(Ui_MainWindow):
    def setupUi(self,MainWindow):
        super().setupUi(MainWindow)
        self.select_points_button.clicked.connect(self.select_end_points)
        self.update_image_crop_button.clicked.connect(self.update_image_crop)
        self.wavelet_button.clicked.connect(self.check_wavelet)
        self.middle_point_button.clicked.connect(self.select_middle_point)
        self.middpoint_update_button.clicked.connect(self.update_midpoint_image)
        self.update_os_button.clicked.connect(self.update_os)
        self.update_cost_button.clicked.connect(self.update_cost)
        self.midline_track_button.clicked.connect(self.midline_tracking)
        self.update_track_display_button.clicked.connect(self.update_track_display)
        self.track_full_screen_button.clicked.connect(self.track_full_screen)
        self.edge_mask_button.clicked.connect(self.edge_mask)
        self.edge_tracks_button.clicked.connect(self.edge_tracking)
        self.edge_tracks_full_screen_button.clicked.connect(self.edge_tracks_full_screen)
        self.save_current_segment_button.clicked.connect(self.save_current_segment)
        self.start_button.clicked.connect(self.start)
        self.draw_segment_button.clicked.connect(self.draw_segment)
        self.save_manuall_segment_button.clicked.connect(self.save_manual_segment)
        self.manual_segment_full_screen_button.clicked.connect(self.manual_segment_full_screen)
        self.check_annotation_button.clicked.connect(self.check_annotation)
        self.skip_image_button.clicked.connect(self.skip_image)
        self.save_annotation_button.clicked.connect(self.save_annotation)
        self.n = 0

        self.select_points_button.setStyleSheet("background-color : red")
        self.skip_image_button.setStyleSheet("background-color : red")
        self.update_image_crop_button.setStyleSheet("background-color : red")
        self.middle_point_button.setStyleSheet("background-color : red")
        self.middpoint_update_button.setStyleSheet("background-color : red")
        self.update_os_button.setStyleSheet("background-color : red")
        self.update_cost_button.setStyleSheet("background-color : red")
        self.midline_track_button.setStyleSheet("background-color : red")
        self.update_track_display_button.setStyleSheet("background-color : red")
        self.track_full_screen_button.setStyleSheet("background-color : red")
        self.edge_mask_button.setStyleSheet("background-color : red")
        self.edge_tracks_button.setStyleSheet("background-color : red")
        self.edge_tracks_full_screen_button.setStyleSheet("background-color : red")
        self.save_current_segment_button.setStyleSheet("background-color : red")
        self.check_annotation_button.setStyleSheet("background-color : red")
        self.save_annotation_button.setStyleSheet("background-color : red")
        self.draw_segment_button.setStyleSheet("background-color : red")


        # self.draw_segment_button.setStyleSheet("background-color : red")

    def start(self):
        dir = self.folder_line_edit.text().replace(" \ ", "/" )
        self.image_names = ct.tools.get_files(folder = dir,formats = ['jpg','png'],basename = False)
        annotated_folder = dir
        self.annoteted_files = ct.tools.get_files(folder = annotated_folder,formats = ['json'],basename = True)
        self.select_points_button.setStyleSheet("background-color : lightblue")
        self.skip_image_button.setStyleSheet("background-color : lightblue")
        self.draw_segment_button.setStyleSheet("background-color : lightblue")
        self.next_image()

    def next_image(self):
        self.name = self.image_names[self.n]
        self.n = self.n+1
        self.image_name = os.path.splitext(self.name)[0]
        print(self.name)
        if os.path.basename(os.path.splitext(os.path.splitext(self.name)[0])[0] + '.json') in self.annoteted_files:
            print('exist')
            self.skip_image()
        self.image = ct.tools.image_load(self.name)
        self.original_image = self.image.copy()
        self.filename_label.setText(os.path.basename(self.name))

        self.mid_pt = []
        self.end_points = []
        self.mask = []
        self.crack_tracks = {}
        self.cracks_stored_endpoints = {}
        self.crack_tracks = {}

        self.update_image_crop_button.setStyleSheet("background-color : red")
        self.middle_point_button.setStyleSheet("background-color : red")
        self.middpoint_update_button.setStyleSheet("background-color : red")
        self.update_os_button.setStyleSheet("background-color : red")
        self.update_cost_button.setStyleSheet("background-color : red")
        self.midline_track_button.setStyleSheet("background-color : red")
        self.update_track_display_button.setStyleSheet("background-color : red")
        self.track_full_screen_button.setStyleSheet("background-color : red")
        self.edge_mask_button.setStyleSheet("background-color : red")
        self.edge_tracks_button.setStyleSheet("background-color : red")
        self.edge_tracks_full_screen_button.setStyleSheet("background-color : red")
        self.save_current_segment_button.setStyleSheet("background-color : red")
        self.check_annotation_button.setStyleSheet("background-color : red")
        self.save_annotation_button.setStyleSheet("background-color : red")


    def skip_image(self):
        data = {}
        data["file_name"] = self.name
        data['image class'] = 1
        data["annotations"] = {}
        data["annotations"]["cracks end-points"] = []
        data["annotations"]["crack_pixels"] = []
        data["annotations"]['track'] = []
        json_file = json.dumps(data)
        with open(os.path.splitext(os.path.splitext(self.name)[0])[0] + '.json', 'w') as f:    
            f.write(json_file)   
        self.next_image()


    def select_end_points(self):
        self.image_size = self.select_image_size.value()
        ptss = ct.tools.Draw().points(self.image[:,:,::-1],self.image_size,move_x = 0,move_y = 0)
        self.end_points = ptss
        self.points_pairs_list = [ptss[b*2:b*2+2] for b in range(len(ptss))]
        if len(self.points_pairs_list) == 2:
            self.update_image_crop_button.setStyleSheet("background-color : lightblue")
            self.middle_point_button.setStyleSheet("background-color : lightblue")
        else:
            self.update_image_crop_button.setStyleSheet("background-color : red")
            self.middle_point_button.setStyleSheet("background-color : red")

    def update_image_crop(self):
        y_margin = self.y_margin_box.value()
        x_margin = self.x_margin_box.value()
        downsample_factor = self.downsample_factor_box.value()
        color_channel = [0 if self.color_chenel_box.currentText()=='R' else 1 if self.color_chenel_box.currentText()=='B' else 2]
        if self.end_points == []:
            self.select_end_points()
        self.pts = self.end_points
        black_crack = [0 if self.crack_color_box.currentText() =='Bright crack' else 1 ][0]
        if black_crack==1:
            func = np.min
        elif  black_crack==0:
            func = np.max
        self.image_crop,self.pts_crop = ct.tools.image_crop(self.original_image,self.pts[0],self.pts[1],self.pts,y_margin,x_margin)
        self.image_crop_down = skimage.measure.block_reduce(self.image_crop, block_size=(downsample_factor, downsample_factor, 1),
                                                func=func, cval=0, func_kwargs=None)
        self.pts_crop_down = [x / downsample_factor for x in self.pts_crop]
        self.image_down = skimage.measure.block_reduce(self.original_image, block_size=(downsample_factor, downsample_factor, 1),
                                                func=func, cval=0, func_kwargs=None)
        self.pts_down = [x / downsample_factor for x in self.pts]
        gs_image = self.image_crop_down[:,:,color_channel].astype(np.uint8)
        gs_image = cv2.circle(gs_image,center = (int(self.pts_crop_down[0][0]),int(self.pts_crop_down[0][1])),
                            radius = 2,color = (0,255,0),thickness = 2)
        gs_image = cv2.circle(gs_image,center = (int(self.pts_crop_down[1][0]),int(self.pts_crop_down[1][1])),
                            radius = 2,color = (0,255,0),thickness = 2)
        qimage = QImage(gs_image.astype(dtype=np.uint8), gs_image.shape[1], gs_image.shape[0], 
                        gs_image.strides[0], QImage.Format_Grayscale8)
        pixmap = QPixmap.fromImage(qimage)
        scaled_pixmap = pixmap.scaled(self.image_crop_down_display.width(), self.image_crop_down_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
        self.image_crop_down_display.setPixmap(scaled_pixmap)
        self.x_size_show.display(self.image_crop_down.shape[1])
        self.y_size_show.display(self.image_crop_down.shape[0])
        self.update_os_button.setStyleSheet("background-color : lightblue")

    
    def check_wavelet(self):
        size = self.wavelet_size_box.value()
        nOrientations = self.wavelet_norientations_box.value()
        design = "N"
        inflectionPoint = self.wavelet_inflection_point_box.value()
        mnOrder = self.wavelet_mnorder_box.value()
        splineOrder = 3
        overlapFactor = self.wavelet_overlap_factor_box.value()
        dcStdDev = self.wavelet_STD_box.value()
        directional = False
        window_size = self.wavelet_window_size_box.value()

        wavelet = ct.os.CheckWavelet(window_size = window_size, size = size, nOrientations = nOrientations, design = design, 
                        inflectionPoint = inflectionPoint, mnOrder = mnOrder, splineOrder = splineOrder,
                        overlapFactor = overlapFactor, dcStdDev = dcStdDev, directional = directional,
                        display_orientations=[0])[0,:,:]
        wavelet = wavelet - np.min(wavelet)
        wavelet = (wavelet*254/np.max(wavelet)).astype(dtype=np.int8)

        qimage = QImage(wavelet.astype(dtype=np.uint8), wavelet.shape[1], wavelet.shape[0], 
                        wavelet.strides[0], QImage.Format_Grayscale8)
        pixmap = QPixmap.fromImage(qimage)
        scaled_pixmap = pixmap.scaled(self.wavelet_check_display.width(), self.wavelet_check_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
        self.wavelet_check_display.setPixmap(scaled_pixmap)

    def select_middle_point(self):
        self.image_size = self.select_image_size.value()
        downsample_factor = self.downsample_factor_box.value()
        mid_pt = ct.tools.Draw().points(self.image[:,:,::-1],self.image_size,move_x = 0,move_y = 0)
        self.mid_pt = (int(mid_pt[0][0]/downsample_factor),int(mid_pt[0][1]/downsample_factor))
        self.middpoint_update_button.setStyleSheet("background-color : lightblue")
        
    def update_midpoint_image(self):
        self.image_size = self.select_image_size.value()
        downsample_factor = self.downsample_factor_box.value()
        color_channel = [0 if self.color_chenel_box.currentText()=='R' else 1 if self.color_chenel_box.currentText()=='B' else 2]
        d = int(self.wavelet_window_size_box.value()/2)
        if self.mid_pt == []:
            self.select_middle_point()
        try :
            mid_image = self.image_down[int(self.mid_pt[1])-d:int(self.mid_pt[1])+d,
                            int(self.mid_pt[0])-d:int(self.mid_pt[0])+d]
        except:
            black_crack = [-1 if self.crack_color_box.currentText() =='Bright crack' else 1 ][0]
            if black_crack==1:
                func = np.min
            elif  black_crack==-1:
                func = np.max
            self.image_down = skimage.measure.block_reduce(self.original_image, block_size=(downsample_factor, downsample_factor, 1),
                                                func=func, cval=0, func_kwargs=None)
            mid_image = self.image_down[int(self.mid_pt[1])-d:int(self.mid_pt[1])+d,
                            int(self.mid_pt[0])-d:int(self.mid_pt[0])+d]
        mid_image = mid_image[:,:,color_channel]
        qimage = QImage(mid_image.astype(dtype=np.uint8), mid_image.shape[1], mid_image.shape[0], 
                        mid_image.strides[0], QImage.Format_Grayscale8)
        pixmap = QPixmap.fromImage(qimage)
        scaled_pixmap = pixmap.scaled(self.middlepoint_display.width(), self.middlepoint_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
        self.middlepoint_display.setPixmap(scaled_pixmap)

    def update_os(self):
        self.os_progress_bar.setValue(0)
        color_channel = [0 if self.color_chenel_box.currentText()=='R' else 1 if self.color_chenel_box.currentText()=='B' else 2][0]
        black_crack = [-1 if self.crack_color_box.currentText() =='Bright crack' else 1 ][0]
        size = self.wavelet_size_box.value()
        nOrientations = self.wavelet_norientations_box.value()
        design = "N"
        inflectionPoint = self.wavelet_inflection_point_box.value()
        mnOrder = self.wavelet_mnorder_box.value()
        splineOrder = 3
        overlapFactor = self.wavelet_overlap_factor_box.value()
        dcStdDev = self.wavelet_STD_box.value()
        directional = False
        self.osGFCost = ct.os.OrientationScoreTransform(self.image_crop_down[:,:,color_channel]/255*black_crack, size = size, 
                                           nOrientations = nOrientations, design = design, 
                                           inflectionPoint = inflectionPoint, mnOrder = mnOrder, 
                                           splineOrder = splineOrder, overlapFactor = overlapFactor, 
                                           dcStdDev = dcStdDev, directional = directional)
        self.os_progress_bar.setValue(100)
        self.update_cost_button.setStyleSheet("background-color : lightblue")

    def update_cost(self):
        self.update_cost_bar.setValue(0)
        lambdaa = self.lambda_box.value()
        p = self.power_box.value()
        ksi = 1
        zeta = 1
        sigmas = self.sigmas_line_edit.text()
        sigmas = [float(i) for i in sigmas.split(sep = ',')]
        sigmas_ext = 1
        self.multiscalecostLIFExtReg = ct.os.MultiScaleVesselness(self.osGFCost.real,ksi,1,sigmas,"LIF",sigmas_ext = sigmas_ext)

        costmultiscale = ct.os.MultiScaleVesselnessFilter(self.multiscalecostLIFExtReg)
        self.costFunction = ct.os.CostFunction(costmultiscale,lambdaa = lambdaa, p = p)
        c00 = np.min(ct.os.Rescale(self.costFunction),axis = 0)
        self.update_cost_bar.setValue(100)
        c00 = c00 - np.min(c00)
        c00 = (c00*255/np.max(c00)).astype(dtype=np.uint8)
        qimage = QImage(c00.astype(dtype=np.uint8), c00.shape[1], c00.shape[0], 
                        c00.strides[0], QImage.Format_Grayscale8)
        pixmap = QPixmap.fromImage(qimage)
        scaled_pixmap = pixmap.scaled(self.cost_display.width(), self.cost_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
        self.cost_display.setPixmap(scaled_pixmap)
        self.midline_track_button.setStyleSheet("background-color : lightblue")

    def midline_tracking(self):
        self.tracking_bar.setValue(0)
        w = self.track_width_box.value()
        if self.track_color_box.currentText() == "R":
            color = (255,0,0)
        elif self.track_color_box.currentText() == "G":
            color = (0,255,0)
        elif self.track_color_box.currentText() == "B":
            color = (0,0,255)
        elif self.track_color_box.currentText() == "W":
            color = (255,255,255)

        y_margin = self.y_margin_box.value()
        x_margin = self.x_margin_box.value()
        g11 = self.g11_box.value()
        g22 = self.g22_box.value()
        g33 = self.g33_box.value()
        x_margin = self.x_margin_box.value()
        downsample_factor = self.downsample_factor_box.value()


        track_crop_down = ct.tracking.fast_marching(self.costFunction,self.pts_crop_down[0],self.pts_crop_down[1],g11=g11,g22=g22,g33=g33)
        track_crop_down[0] = track_crop_down[0]-0.5
        track_crop_down[1] = track_crop_down[1]-0.5
        track_crop = track_crop_down.copy()
        track_crop[0] = track_crop_down[0]*downsample_factor
        track_crop[1] = track_crop_down[1]*downsample_factor
        self.track_crop = track_crop
        track = ct.tools.track_crop_to_full(track_crop,self.pts[0],self.pts[1],y_margin,x_margin)
        self.track = track
        pts = np.array(track_crop).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
        im = self.image_crop.astype(np.uint8)
        im = cv2.polylines(im, [pts], False, color, w)

        qimage = QImage(im, im.shape[1], im.shape[0], 
                        im.strides[0], QImage.Format_RGB888)
        pixmap = QPixmap.fromImage(qimage)
        scaled_pixmap = pixmap.scaled(self.track_display.width(), self.track_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
        self.track_display.setPixmap(scaled_pixmap)
        self.tracking_bar.setValue(100)
        self.update_track_display_button.setStyleSheet("background-color : lightblue")
        self.track_full_screen_button.setStyleSheet("background-color : lightblue")
        self.edge_mask_button.setStyleSheet("background-color : lightblue")
    
    def update_track_display(self):
        w = self.track_width_box.value()
        if self.track_color_box.currentText() == "R":
            color = (255,0,0)
        elif self.track_color_box.currentText() == "G":
            color = (0,255,0)
        elif self.track_color_box.currentText() == "B":
            color = (0,0,255)
        elif self.track_color_box.currentText() == "W":
            color = (255,255,255)
        pts = np.array(self.track_crop).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
        im = self.image_crop.astype(np.uint8)
        im = cv2.polylines(im, [pts], False, color, w)
        qimage = QImage(im, im.shape[1], im.shape[0], 
                        im.strides[0], QImage.Format_RGB888)
        pixmap = QPixmap.fromImage(qimage)
        scaled_pixmap = pixmap.scaled(self.track_display.width(), self.track_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
        self.track_display.setPixmap(scaled_pixmap)

    def track_full_screen(self):
        w = self.track_width_box.value()
        if self.track_color_box.currentText() == "R":
            color = (255,0,0)
            c = 'r'
        elif self.track_color_box.currentText() == "G":
            color = (0,255,0)
            c = 'g'
        elif self.track_color_box.currentText() == "B":
            color = (0,0,255)
            c = 'b'
        elif self.track_color_box.currentText() == "W":
            color = (255,255,255)
            c = 'w'

        im = self.image.astype(np.uint8)
        plt.imshow(im)
        plt.plot(self.track[0],self.track[1],color = c,linewidth=w)
        plt.show()

    def edge_mask(self):
        window_half_size = int(self.edge_filter_size_box.value()/2)

        y_margin = self.y_margin_box.value()
        x_margin = self.x_margin_box.value()


        black_crack = [-1 if self.crack_color_box.currentText() =='Bright crack' else 1 ][0]
        color_channel = [0 if self.color_chenel_box.currentText()=='R' else 1 if self.color_chenel_box.currentText()=='B' else 2][0]
        self.edge_mask1, self.edge_mask2 = ct.segmentation.edge_masks(self.original_image[:,:,color_channel]*black_crack,np.array(self.track),window_half_size=window_half_size)

        self.edge_mask1_crop,pts_crop = ct.tools.image_crop(self.edge_mask1[:,:,np.newaxis],self.pts[0],self.pts[1],self.pts,y_margin,x_margin)
        self.edge_mask2_crop,pts_crop = ct.tools.image_crop(self.edge_mask2[:,:,np.newaxis],self.pts[0],self.pts[1],self.pts,y_margin,x_margin)

        edge_mask1_crop = self.edge_mask1_crop - np.min(self.edge_mask1_crop)
        edge_mask1_crop = (edge_mask1_crop*255/np.max(edge_mask1_crop)).astype(dtype=np.uint8)

        qimage = QImage(edge_mask1_crop.astype(dtype=np.uint8), edge_mask1_crop.shape[1], edge_mask1_crop.shape[0], 
                        edge_mask1_crop.strides[0], QImage.Format_Grayscale8)
        pixmap = QPixmap.fromImage(qimage)
        scaled_pixmap = pixmap.scaled(self.edge_map_display.width(), self.edge_map_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
        self.edge_map_display.setPixmap(scaled_pixmap)
        self.edge_tracks_button.setStyleSheet("background-color : lightblue")

    def edge_tracking(self):
        color_channel = [0 if self.color_chenel_box.currentText()=='R' else 1 if self.color_chenel_box.currentText()=='B' else 2][0]
        y_margin = self.y_margin_box.value()
        x_margin = self.x_margin_box.value()

        w = self.edge_track_width_box.value()
        if self.edge_track_color_box.currentText() == "R":
            color = (255,0,0)
        elif self.edge_track_color_box.currentText() == "G":
            color = (0,255,0)
        elif self.edge_track_color_box.currentText() == "B":
            color = (0,0,255)
        elif self.edge_track_color_box.currentText() == "W":
            color = (255,255,255)

        mu = self.mu_box.value()
        l = self.l_box.value()
        p = self.p_box.value()

        track_e1_crop, track_e2_crop = ct.segmentation.edges_tracking(self.image_crop[:,:,color_channel], self.pts_crop, 
                                                    self.edge_mask1_crop,self.edge_mask2_crop, mu = mu,l = l, p = p)
        track_e1_crop = track_e1_crop[::-1]
        track_e2_crop = track_e2_crop[::-1]

        track_e1_crop[0] = track_e1_crop[0] - 0.5
        track_e2_crop[0] = track_e2_crop[0] - 0.5

        track_e1_crop[1] = track_e1_crop[1] - 0.5
        track_e2_crop[1] = track_e2_crop[1] - 0.5

        self.track_e1 = ct.tools.track_crop_to_full(track_e1_crop,self.pts[0],self.pts[1],y_margin,x_margin)
        self.track_e2 = ct.tools.track_crop_to_full(track_e2_crop,self.pts[0],self.pts[1],y_margin,x_margin)


        pts1 = np.array(track_e1_crop).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
        pts2 = np.array(track_e2_crop).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
        im = self.image_crop.astype(np.uint8)
        im = cv2.polylines(im, [pts1], False, color, w)
        im = cv2.polylines(im, [pts2], False, color, w)
        qimage = QImage(im, im.shape[1], im.shape[0], 
                        im.strides[0], QImage.Format_RGB888)
        pixmap = QPixmap.fromImage(qimage)
        scaled_pixmap = pixmap.scaled(self.edge_tracks_display.width(), self.edge_tracks_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
        self.edge_tracks_display.setPixmap(scaled_pixmap)
        self.edge_tracks_full_screen_button.setStyleSheet("background-color : lightblue")
        self.edge_tracks_full_screen_button.setStyleSheet("background-color : lightblue")
        self.save_current_segment_button.setStyleSheet("background-color : lightblue")

    def edge_tracks_full_screen(self):
        
        w = self.edge_track_width_box.value()
        if self.edge_track_color_box.currentText() == "R":
            c = 'r'
        elif self.edge_track_color_box.currentText() == "G":
            c = 'g'
        elif self.edge_track_color_box.currentText() == "B":
            c = 'b'
        elif self.edge_track_color_box.currentText() == "W":
            c = 'w'

        im = self.image.astype(np.uint8)
        plt.imshow(im)
        plt.plot(self.track_e1[0],self.track_e1[1],color = c,linewidth=w)
        plt.plot(self.track_e2[0],self.track_e2[1],color = c,linewidth=w)
        plt.show()

    def save_current_segment(self):
        edge_x = np.concatenate((self.track_e1[1][::-1],self.track_e2[1]))
        edge_y = np.concatenate((self.track_e1[0][::-1],self.track_e2[0]))

        mask_FM = ct.segmentation.create_mask(self.image,edge_y,edge_x)
        self.mask.append(mask_FM)
        track = [list(x) for x in self.track]
        self.cracks_stored_endpoints[len(self.cracks_stored_endpoints.keys())] = [self.pts[0].tolist(),self.pts[1].tolist()]
        self.crack_tracks[len(self.crack_tracks)] = track
        m = np.sum(np.array(self.mask),axis = 0)
        m[m>=1] = 255
        m = m.astype(dtype=np.uint8)
        qimage = QImage(m.astype(dtype=np.uint8), m.shape[1], m.shape[0], 
                        m.strides[0], QImage.Format_Grayscale8)
        pixmap = QPixmap.fromImage(qimage)
        scaled_pixmap = pixmap.scaled(self.all_segments_display.width(), self.all_segments_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
        self.all_segments_display.setPixmap(scaled_pixmap)

        pts1 = np.array(self.track_e1).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
        pts2 = np.array(self.track_e2).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
        im = self.image.astype(np.uint8).copy()
        im = cv2.polylines(im, [pts1], False, (0,255,0), 1)
        im = cv2.polylines(im, [pts2], False, (0,255,0), 1)
        self.image = im
        self.check_annotation_button.setStyleSheet("background-color : lightblue")
        self.save_annotation_button.setStyleSheet("background-color : lightblue")

        # plt.imshow(m)
        # plt.plot(self.track_e1[0],self.track_e1[1],'r')
        # plt.plot(self.track_e2[0],self.track_e2[1],'r')
        # plt.show()

    def draw_segment(self):
        image_size = self.select_image_size.value()
        x,y = ct.tools.Draw().counturs(self.image[:,:,::-1],image_size)
        if len(x) == 0:
            return
        x = np.concatenate([x,np.array(x[0]).reshape(1)])
        y = np.concatenate([y,np.array(y[0]).reshape(1)])
        self.manuall_x = np.array(x)
        self.manuall_y = np.array(y)

        pts = np.array([x,y]).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
        im = self.image.astype(np.uint8)
        im = cv2.polylines(im, [pts], False, (0, 255, 0), 1)

        qimage = QImage(im, im.shape[1], im.shape[0], 
                        im.strides[0], QImage.Format_RGB888)
        pixmap = QPixmap.fromImage(qimage)
        scaled_pixmap = pixmap.scaled(self.manual_segment_screen.width(), self.manual_segment_screen.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
        self.manual_segment_screen.setPixmap(scaled_pixmap)

    def manual_segment_full_screen(self):
        pts = np.array([self.manuall_x,self.manuall_y]).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
        im = self.image.astype(np.uint8).copy()
        plt.imshow(im)
        plt.plot(self.manuall_x,self.manuall_y,'r',linewidth = 1)
        plt.show()

    def save_manual_segment(self):
        mask_FM = ct.segmentation.create_mask(self.image,self.manuall_x,self.manuall_y)
        self.mask.append(mask_FM)
        m = np.sum(np.array(self.mask),axis = 0)
        m[m>=1] = 255
        m = m.astype(dtype=np.uint8)
        pts = np.array([self.manuall_x,self.manuall_y]).transpose(1,0).reshape((-1,1,2)).astype(np.int32)
        im = self.image.astype(np.uint8).copy()
        im = cv2.polylines(im, [pts], False, (0,255,0), 1)
        self.image = im
        self.check_annotation_button.setStyleSheet("background-color : lightblue")
        self.save_annotation_button.setStyleSheet("background-color : lightblue")

    def check_annotation(self):
        im = self.original_image.astype(np.uint8)
        qimage = QImage(im, im.shape[1], im.shape[0], 
                        im.strides[0], QImage.Format_RGB888)
        pixmap = QPixmap.fromImage(qimage)
        scaled_pixmap = pixmap.scaled(self.original_image_display.width(), self.original_image_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
        self.original_image_display.setPixmap(scaled_pixmap)

        m = np.sum(np.array(self.mask),axis = 0)
        m[m>=1] = 255
        m = m.astype(dtype=np.uint8)
        qimage = QImage(m, m.shape[1], m.shape[0], 
                        m.strides[0], QImage.Format_Grayscale8)
        pixmap = QPixmap.fromImage(qimage)
        scaled_pixmap = pixmap.scaled(self.segmentation_mask_display.width(), self.segmentation_mask_display.height(), Qt.KeepAspectRatio, Qt.FastTransformation)
        self.segmentation_mask_display.setPixmap(scaled_pixmap)

    def save_annotation(self):
        data = {}
        data["file_name"] = self.name
        data["annotations"] = {}
        data["annotations"]["cracks end-points"] = self.cracks_stored_endpoints
        m = np.sum(np.array(self.mask),axis = 0)
        m[m>=1] = 1.0
        crack_pixels = np.argwhere(m==1.0)
        data["annotations"]["crack_pixels"] = crack_pixels.tolist()
        data["annotations"]['tracks'] = self.crack_tracks
        json_file = json.dumps(data)
        with open(os.path.splitext(os.path.splitext(self.name)[0])[0] + '.json', 'w') as f:        
            f.write(json_file)   
        self.next_image()
        self.update_image_crop_button.setStyleSheet("background-color : red")
        self.middle_point_button.setStyleSheet("background-color : red")
        self.middpoint_update_button.setStyleSheet("background-color : red")
        self.update_os_button.setStyleSheet("background-color : red")
        self.update_cost_button.setStyleSheet("background-color : red")
        self.midline_track_button.setStyleSheet("background-color : red")
        self.update_track_display_button.setStyleSheet("background-color : red")
        self.track_full_screen_button.setStyleSheet("background-color : red")
        self.edge_mask_button.setStyleSheet("background-color : red")
        self.edge_tracks_button.setStyleSheet("background-color : red")
        self.edge_tracks_full_screen_button.setStyleSheet("background-color : red")
        self.save_current_segment_button.setStyleSheet("background-color : red")
        self.check_annotation_button.setStyleSheet("background-color : red")
        self.save_annotation_button.setStyleSheet("background-color : red")



if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = CrackToolsApplication()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
